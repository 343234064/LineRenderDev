using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using UnityEditor;
using UnityEngine;
using UnityEngine.Rendering;

public struct AdjFace
{
    public uint x;
    public uint y;
    public uint z;
    public uint xy;
    public uint yz;
    public uint zx;
}

/// <summary>
/// Static Mesh Ver
/// 
/// </summary>
/// 

/// setbuffer移到start()
/// vertex采用append方式
public class LinesRenderer : MonoBehaviour
{
    public class RenderContext
    {
        public int MeshCount;
        public int[] TriangleOffset;
        public int[] VertexOffset;
        public AdjFace[] TotalAdjacencyTriangles;
        public Vector3[] TotalVertices;

        public ComputeBuffer AdjacencyIndicesBuffer;
        public ComputeBuffer VerticesBuffer;
        public ComputeBuffer ExtractLineBuffer;
        public ComputeBuffer ExtractLineArgBuffer;

        public int ExtractLinePassGroupSize;

        public Bounds BoundingVolume;

        public void Destroy()
        {
            if (AdjacencyIndicesBuffer != null)
                AdjacencyIndicesBuffer.Release();
            if (VerticesBuffer != null)
                VerticesBuffer.Release();
            if (ExtractLineBuffer != null)
                ExtractLineBuffer.Release();
            if (ExtractLineArgBuffer != null)
                ExtractLineArgBuffer.Release();
        }
    }

    public class MeshData
    {
        public Mesh RumtimeMesh;
        public Transform RumtimeTransform;
        public AdjFace[] AdjacencyTriangles;

        public MeshData(Mesh meshObj, Transform transform)
        {
            RumtimeMesh = meshObj;
            RumtimeTransform = transform;
        }

        public void Destroy()
        {}
    }

    // Start is called before the first frame update
    void Start()
    {
        GetMeshInformation();
        if (Enable)
        {
            LoadAdjacency();

            Setup();
        }
    }

    // Update is called once per frame
    void Update()
    {
        if (Enable)
        {
            //for (int i = 0; i < MeshList.Count; i++)
            {
                ExtractLineShader.SetBuffer(ExtractLineShaderKernelId, "Vertices", Context.VerticesBuffer);
                ExtractLineShader.SetBuffer(ExtractLineShaderKernelId, "LineIndices", Context.ExtractLineBuffer);
                ExtractLineShader.SetBuffer(ExtractLineShaderKernelId, "AdjacencyTriangles", Context.AdjacencyIndicesBuffer);
   
                ExtractLineShader.SetInt("TotalAdjacencyTrianglesNum", Context.TotalAdjacencyTriangles.Length);
                Context.ExtractLineBuffer.SetCounterValue(0);
                ExtractLineShader.Dispatch(ExtractLineShaderKernelId, Context.ExtractLinePassGroupSize, 1, 1);


                ComputeBuffer.CopyCount(Context.ExtractLineBuffer, Context.ExtractLineArgBuffer, 0);
                int[] Args = new int[] { 0 };
                Context.ExtractLineArgBuffer.GetData(Args);

                Debug.Log("Group Size : " + Context.ExtractLinePassGroupSize);
                Debug.Log("Instance Count " + Args[0]);
                //Debug.Log("Mesh: " + i);
                Matrix4x4 WorldMatrix = MeshList[0].RumtimeTransform.localToWorldMatrix;
                LineRenderMaterial.SetMatrix("_ObjectWorldMatrix", WorldMatrix);
                LineRenderMaterial.SetBuffer("LinesIndex", Context.ExtractLineBuffer);
                LineRenderMaterial.SetBuffer("Positions", Context.VerticesBuffer);

                //Graphics.DrawProceduralIndirect(LineRenderMaterial, BoundingVolume, MeshTopology.Lines, MeshList[i].ExtractLineArgBuffer, 0);
                Graphics.DrawProcedural(LineRenderMaterial, Context.BoundingVolume, MeshTopology.Lines, 2, Args[0]);
            }
        }
    }



    void OnEnable()
    {
        Camera.onPostRender += OnPostRenderCallback;
    }

    void OnDestroy()
    {
        Camera.onPostRender -= OnPostRenderCallback;
        for (int i = 0; i < MeshList.Count; i++)
        {
            MeshList[i].Destroy();
        }
        if(Context != null)
            Context.Destroy();
    }

    private void OnPostRenderCallback(Camera camera)
    {

    }




    /// ///////////////////////////////////////////////////////
    public bool Enable;
    public Material LineRenderMaterial;
    public ComputeShader ExtractLineShader;
    /// ///////////////////////////////////////////////////////
    private List<MeshData> MeshList;
    private RenderContext Context;

    private int ExtractLineShaderKernelId;
    private uint ExtractLineShaderGroupSize;
    /// ///////////////////////////////////////////////////////


    private void GetMeshInformation()
    {
        MeshList = new List<MeshData>();

        MeshFilter SelectedMesh = gameObject.GetComponent<MeshFilter>();
        if (SelectedMesh == null)
        {
            int SubNodesNum = gameObject.transform.childCount;
            if (SubNodesNum != 0)
            {
                for (int i = 0; i < SubNodesNum; i++)
                {
                    GameObject child = gameObject.transform.GetChild(i).gameObject;
                    MeshFilter SubMesh = child.GetComponent<MeshFilter>();
                    if (SubMesh == null) break;
                    else
                    {
                        MeshData ToAdd = new MeshData(SubMesh.sharedMesh, child.transform);
                        MeshList.Add(ToAdd);
                    }
                }
            }
        }
        else
        {
            MeshData ToAdd = new MeshData(SelectedMesh.sharedMesh, gameObject.transform);
            MeshList.Add(ToAdd);
        }

        Debug.Log("Mesh Name: " + gameObject.name);
        Debug.Log("Mesh Count: " + MeshList.Count);
    }


    private void LoadAdjacency()
    {
        if (MeshList.Count == 0) return;

        string FileName = AssetDatabase.GetAssetPath(MeshList[0].RumtimeMesh);
        int dotIndex = FileName.LastIndexOf('.');
        if (dotIndex != -1)
        {
            FileName = FileName.Substring(0, dotIndex);
        }
        FileName += ".adjacency";
        Debug.Log("Start Load Adjacency : " + FileName);

        if (File.Exists(FileName))
        {
            using (BinaryReader Reader = new BinaryReader(File.Open(FileName, FileMode.Open)))
            {
                int MeshNum = Reader.ReadInt32();
                int OffsetPerData = Reader.ReadInt32();
                Debug.Log("Mesh Num:" + MeshNum);
                Debug.Log("Offset Per Data:" + OffsetPerData);

                if (MeshNum == MeshList.Count)
                {
                    uint IndexOffset = 0;
                    for (int i = 0; i < MeshNum; i++)
                    {
                        int TotalAdjFaceNum = Reader.ReadInt32();
                        Debug.Log("Mesh : " + i + " | Total AdjFace Num:" + TotalAdjFaceNum);
                        MeshList[i].AdjacencyTriangles = new AdjFace[TotalAdjFaceNum];
                        

                        int Offset = 0;
                        for (int j = 0; j < TotalAdjFaceNum; j++)
                        {
                            AdjFace Face = new AdjFace();
                            Face.x = (uint)Reader.ReadInt32() + IndexOffset;
                            Face.y = (uint)Reader.ReadInt32() + IndexOffset;
                            Face.z = (uint)Reader.ReadInt32() + IndexOffset;
                            Face.xy = (uint)Reader.ReadInt32();
                            if (Face.xy != 0) Face.xy += IndexOffset;
                            Face.yz = (uint)Reader.ReadInt32();
                            if (Face.yz != 0) Face.yz += IndexOffset;
                            Face.zx = (uint)Reader.ReadInt32();
                            if (Face.zx != 0) Face.zx += IndexOffset;

                            MeshList[i].AdjacencyTriangles[Offset] = Face; 
                            Offset++;
                        }

                        IndexOffset += (uint)MeshList[i].RumtimeMesh.vertices.Length;
                    }
                }
                else
                {
                    Debug.Log("Mesh Num From File Not Equal To Current Mesh.");
                }
            }

        }
        else
        {
            Debug.Log("Cannot Find Adjacency File.....");
        }

        Debug.Log("Load Adjacency Completed.");
    }

    void Setup()
    { 
        /*
        ComputeShader[] ComputeShaderList = (ComputeShader[])Resources.FindObjectsOfTypeAll(typeof(ComputeShader));
        for (int i = 0; i < ComputeShaderList.Length; i++)
        {
            Debug.Log(ComputeShaderList[i].name);
            if (ComputeShaderList[i].name == "ExtractLine")
                ExtractLineShader = ComputeShaderList[i];
        }*/

        ExtractLineShaderKernelId = ExtractLineShader.FindKernel("CSMain");
        ExtractLineShader.GetKernelThreadGroupSizes(ExtractLineShaderKernelId, out ExtractLineShaderGroupSize, out _, out _);

        Context = new RenderContext();
        Context.BoundingVolume = new Bounds(Vector3.zero, Vector3.one * 20);
        Context.MeshCount = MeshList.Count;
        Context.TriangleOffset = new int[Context.MeshCount];
        Context.VertexOffset = new int[Context.MeshCount];

        int TotalAdjacencyTriangleNum = 0;
        int TotalVertexNum = 0;
        for (int i = 0; i < MeshList.Count; i++)
        {
            Context.TriangleOffset[i] = TotalAdjacencyTriangleNum;
            Context.VertexOffset[i] = TotalVertexNum;
            TotalAdjacencyTriangleNum += MeshList[i].AdjacencyTriangles.Length;
            TotalVertexNum += MeshList[i].RumtimeMesh.vertices.Length;
        }
        Context.TotalAdjacencyTriangles = new AdjFace[TotalAdjacencyTriangleNum];
        Context.TotalVertices = new Vector3[TotalVertexNum];

        for (int i = 0; i < MeshList.Count; i++)
        {
            MeshList[i].AdjacencyTriangles.CopyTo(Context.TotalAdjacencyTriangles, Context.TriangleOffset[i]);
            MeshList[i].RumtimeMesh.vertices.CopyTo(Context.TotalVertices, Context.VertexOffset[i]);
        }

        Context.AdjacencyIndicesBuffer = new ComputeBuffer(Context.TotalAdjacencyTriangles.Length, sizeof(uint) * 6);
        Context.AdjacencyIndicesBuffer.SetData(Context.TotalAdjacencyTriangles);

        Context.VerticesBuffer = new ComputeBuffer(Context.TotalVertices.Length, sizeof(float) * 3);
        Context.VerticesBuffer.SetData(Context.TotalVertices);

        Context.ExtractLineBuffer = new ComputeBuffer(Context.TotalAdjacencyTriangles.Length * 3, sizeof(uint) * 2, ComputeBufferType.Append);

        Context.ExtractLineArgBuffer = new ComputeBuffer(1, sizeof(int), ComputeBufferType.IndirectArguments);
        int[] args = new int[] { 0 };
        Context.ExtractLineArgBuffer.SetData(args);
        ComputeBuffer.CopyCount(Context.ExtractLineBuffer, Context.ExtractLineArgBuffer, 0);

        Context.ExtractLinePassGroupSize = ((int)(Context.TotalAdjacencyTriangles.Length / ExtractLineShaderGroupSize) + 1);








    }

   

}
