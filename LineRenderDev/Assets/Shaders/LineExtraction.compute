// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct AdjFace
{
    uint x;
    uint y;
    uint z;
    uint xy;
    uint yz;
    uint zx;
};

struct LineSegment
{
    float3 LocalPosition[2];
    float4 NDCPosition[2];

    int Extracted;
    int Visible;
};

cbuffer Constants
{
    uint TotalAdjacencyTrianglesNum;
    uint SilhouetteEnable;
    uint CreaseEnable;
    uint BorderEnable;
    uint HideBackFaceEdge;
    uint HideOccludedEdge;
};


StructuredBuffer<float3> Vertices;
StructuredBuffer<AdjFace> AdjacencyTriangles;

RWStructuredBuffer<LineSegment> Segments;

uniform float3 LocalSpaceViewPosition;
uniform float CreaseAngleThreshold;
uniform float4x4 WorldViewProjection;


float3 ComputeNormal(float3 p1, float3 p2, float3 p3)
{
    float3 U = p2 - p1;
    float3 V = p3 - p1;

    float3 Normal = float3(0.0f, 0.0f, 0.0f);
    /*
    Normal.x = U.y * V.z - U.z * V.y;
    Normal.y = U.z * V.x - U.x * V.z;
    Normal.z = U.x * V.y - U.y * V.x;
    */
    Normal = cross(U, V);
    // No need to normalize
    //Normal = normalize(Normal);

    return Normal;
}



inline bool IsSilhouette(float DotFactor1, float DotFactor2)
{
    return step(DotFactor1 * DotFactor2, 0);
}

inline bool IsCrease(float3 Face1Normal, float3 Face2Normal, float AngleThreshold)
{
    /// a dot b / (|a| * |b|) <= cos(theta)
    return step(dot(Face1Normal, Face2Normal) / length(Face2Normal), AngleThreshold);

}


#define NDCLEFT -1.0
#define NDCRIGHT 1.0
#define NDCTOP 1.0
#define NDCBOTTOM -1.0

inline bool IsIntersectWithXPlane(float3 LinePoint1, float LineKFactor, float XPlane, float2 LineXMinMax)
{
    float Y = (XPlane - LinePoint1.x) * LineKFactor + LinePoint1.y;
    if ((Y >= NDCBOTTOM && Y <= NDCTOP) && (XPlane >= LineXMinMax.x && XPlane <= LineXMinMax.y)) return true;
    else return false;
}

inline bool IsIntersectWithYPlane(float3 LinePoint1, float LineKFactor, float YPlane, float2 LineYMinMax)
{
    float X = (YPlane - LinePoint1.y) * LineKFactor + LinePoint1.x;
    if ((X >= NDCLEFT && X <= NDCRIGHT) && (YPlane >= LineYMinMax.x && YPlane <= LineYMinMax.y)) return true;
    else return false;
}

inline bool IsIn(float3 LinePoint1, float3 LinePoint2)
{
    bool Poine1IsIn = (LinePoint1.x >= NDCLEFT && LinePoint1.x <= NDCRIGHT) && (LinePoint1.y >= NDCBOTTOM && LinePoint1.y <= NDCTOP);
    bool Poine2IsIn = (LinePoint2.x >= NDCLEFT && LinePoint2.x <= NDCRIGHT) && (LinePoint2.y >= NDCBOTTOM && LinePoint2.y <= NDCTOP);

    return Poine1IsIn && Poine2IsIn;
}

bool PreClipping(LineSegment Line)
{
    float3 NDCPos1 = Line.NDCPosition[0].xyz;
    float3 NDCPos2 = Line.NDCPosition[1].xyz;

    if (IsIn(NDCPos1, NDCPos2))
        return false;
    else {
        float KFactorX = (NDCPos2.y - NDCPos1.y) / (NDCPos2.x - NDCPos1.x);
        float KFactorY = (NDCPos2.x - NDCPos1.x) / (NDCPos2.y - NDCPos1.y);
        float2 LineXMinMax = float2(min(NDCPos1.x, NDCPos2.x), max(NDCPos1.x, NDCPos2.x));
        float2 LineYMinMax = float2(min(NDCPos1.y, NDCPos2.y), max(NDCPos1.y, NDCPos2.y));

        bool IntersectLeft = IsIntersectWithXPlane(NDCPos1, KFactorX, NDCLEFT, LineXMinMax);
        bool IntersectRight = IsIntersectWithXPlane(NDCPos1, KFactorX, NDCRIGHT, LineXMinMax);
        bool IntersectTop = IsIntersectWithYPlane(NDCPos1, KFactorY, NDCTOP, LineYMinMax);
        bool IntersectBottom = IsIntersectWithYPlane(NDCPos1, KFactorY, NDCBOTTOM, LineYMinMax);

        if (IntersectLeft || IntersectRight || IntersectTop || IntersectBottom)
            return false;
        else
            return true;
    }
}

inline float4 GetNDCPosition(float3 LocalPosition)
{
    float4 Transformed = mul(WorldViewProjection, float4(LocalPosition, 1.0));
    //In NDC space, XY range in [-1.0, 1.0]
    //In Direct3D, Z range in [0.0, 1.0]. (If is reversed-z, it will be [1.0, 0.0] in unity)
    //In OpenGL, Z range in [-1.0, 1.0].
    //w might be 0(degenerate case)
    Transformed.xyz = Transformed.xyz / Transformed.w;

    return Transformed;
}


void Preprocess(LineSegment Line, uint id, uint offset)
{
    uint LineIndex = id * 3 + offset;

    Segments[LineIndex].LocalPosition[0] = Line.LocalPosition[0];
    Segments[LineIndex].LocalPosition[1] = Line.LocalPosition[1];
    Segments[LineIndex].NDCPosition[0] = Line.NDCPosition[0];
    Segments[LineIndex].NDCPosition[1] = Line.NDCPosition[1];
    Segments[LineIndex].Extracted = Line.Extracted;
    Segments[LineIndex].Visible = Line.Visible;
}



[numthreads(256, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= TotalAdjacencyTrianglesNum) return;

    AdjFace CurrentFace = AdjacencyTriangles[id.x];

    float3 VertexX = Vertices[CurrentFace.x];
    float3 VertexY = Vertices[CurrentFace.y];
    float3 VertexZ = Vertices[CurrentFace.z];

    bool AddXY = false;
    bool AddYZ = false;
    bool AddZX = false;

    bool XYIsBackFace = false;
    bool ZXIsBackFace = false;
    bool YZIsBackFace = false;

    float3 CurrentFaceNormal = ComputeNormal(VertexX, VertexY, VertexZ);

    bool NeedExtractSilhouette =  SilhouetteEnable > 0;
    float3 LocalViewVector = LocalSpaceViewPosition.xyz - (VertexX+VertexY+VertexZ)/3.0f;
    float SilhouettePremultiplyDotFactor = dot(CurrentFaceNormal, LocalViewVector);

    bool NeedExtractCrease = CreaseEnable > 0;
    float CreasePremultiplyAngleThreshold = length(CurrentFaceNormal) * (cos(CreaseAngleThreshold) + 0.000001f); //+1.0e-6 for Epsilon

    bool CurrentIsBackFace = SilhouettePremultiplyDotFactor < 0 ? true : false;


    if (CurrentFace.xy >= 1)
    {
        float3 AdjVertexXY = Vertices[CurrentFace.xy - 1];
        float3 AdjFaceXYNormal = ComputeNormal(VertexY, VertexX, AdjVertexXY);

        float DotFactor = dot(LocalViewVector, AdjFaceXYNormal);
        AddXY = AddXY || (NeedExtractSilhouette && IsSilhouette(SilhouettePremultiplyDotFactor, DotFactor));
        AddXY = AddXY || (NeedExtractCrease && IsCrease(CurrentFaceNormal, AdjFaceXYNormal, CreasePremultiplyAngleThreshold));

        XYIsBackFace = DotFactor < 0 ? true : false;
        bool XYBackFacing = CurrentIsBackFace && XYIsBackFace;

        LineSegment Line;
        Line.LocalPosition[0] = Vertices[CurrentFace.x];
        Line.LocalPosition[1] = Vertices[CurrentFace.y];
        Line.NDCPosition[0] = GetNDCPosition(Vertices[CurrentFace.x]);
        Line.NDCPosition[1] = GetNDCPosition(Vertices[CurrentFace.y]);
        Line.Extracted = 0;
        Line.Visible = XYBackFacing ? 0 : 1;

        if (AddXY && !PreClipping(Line))
        {
            Line.Extracted = 1;
        }

        Preprocess(Line, id.x, 0);
    }

    if (CurrentFace.zx >= 1)
    {
        float3 AdjVertexZX = Vertices[CurrentFace.zx - 1];
        float3 AdjFaceZXNormal = ComputeNormal(VertexZ, AdjVertexZX, VertexX);

        float DotFactor = dot(LocalViewVector, AdjFaceZXNormal);
        AddZX = AddZX || (NeedExtractSilhouette && IsSilhouette(SilhouettePremultiplyDotFactor, DotFactor));
        AddZX = AddZX || (NeedExtractCrease && IsCrease(CurrentFaceNormal, AdjFaceZXNormal, CreasePremultiplyAngleThreshold));

        ZXIsBackFace = DotFactor < 0 ? true : false;
        bool ZXBackFacing = CurrentIsBackFace && ZXIsBackFace;

        LineSegment Line;
        Line.LocalPosition[0] = Vertices[CurrentFace.z];
        Line.LocalPosition[1] = Vertices[CurrentFace.x];
        Line.NDCPosition[0] = GetNDCPosition(Vertices[CurrentFace.z]);
        Line.NDCPosition[1] = GetNDCPosition(Vertices[CurrentFace.x]);
        Line.Extracted = 0;
        Line.Visible = ZXBackFacing ? 0 : 1;

        if (AddZX && !PreClipping(Line))
        {
            Line.Extracted = 1;
        }

        Preprocess(Line, id.x, 1);
    }

    if (CurrentFace.yz >= 1)
    {
        float3 AdjVertexYZ = Vertices[CurrentFace.yz - 1];
        float3 AdjFaceYZNormal = ComputeNormal(AdjVertexYZ, VertexZ, VertexY);

        float DotFactor = dot(LocalViewVector, AdjFaceYZNormal);
        AddYZ = AddYZ || (NeedExtractSilhouette && IsSilhouette(SilhouettePremultiplyDotFactor, DotFactor));
        AddYZ = AddYZ || (NeedExtractCrease && IsCrease(CurrentFaceNormal, AdjFaceYZNormal, CreasePremultiplyAngleThreshold));

        YZIsBackFace = DotFactor < 0 ? true : false;
        bool YZBackFacing = CurrentIsBackFace && YZIsBackFace;

        LineSegment Line;
        Line.LocalPosition[0] = Vertices[CurrentFace.y];
        Line.LocalPosition[1] = Vertices[CurrentFace.z];
        Line.NDCPosition[0] = GetNDCPosition(Vertices[CurrentFace.y]);
        Line.NDCPosition[1] = GetNDCPosition(Vertices[CurrentFace.z]);
        Line.Extracted = 0;
        Line.Visible = YZBackFacing ? 0 : 1;

        if (AddYZ && !PreClipping(Line))
        {
            Line.Extracted = 1;
        }

        Preprocess(Line, id.x, 2);
    }


}
