// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Extraction

#include "Common.cginc"



StructuredBuffer<float3> Vertices;
StructuredBuffer<AdjFace> AdjacencyTriangles;
RWStructuredBuffer<int> ArgBuffer;
AppendStructuredBuffer<LineSegment> Segments;

uniform float3 LocalSpaceViewPosition;
uniform float CreaseAngleThreshold;
uniform float4x4 WorldViewProjection;
uniform float4x4 WorldViewProjectionForClipping;
uniform int ScreenWidth;
uniform int ScreenHeight;


#define DEBUG_CLIPPING 0


float3 ComputeNormal(float3 p1, float3 p2, float3 p3)
{
    float3 U = p2 - p1;
    float3 V = p3 - p1;

    float3 Normal = float3(0.0f, 0.0f, 0.0f);
    /*
    Normal.x = U.y * V.z - U.z * V.y;
    Normal.y = U.z * V.x - U.x * V.z;
    Normal.z = U.x * V.y - U.y * V.x;
    */
    Normal = cross(U, V);
    // No need to normalize
    //Normal = normalize(Normal);

    return Normal;
}



inline bool IsSilhouette(float DotFactor1, float DotFactor2)
{
    return step(DotFactor1 * DotFactor2, 0);
}

inline bool IsCrease(float3 Face1Normal, float3 Face2Normal, float AngleThreshold)
{
    /// a dot b / (|a| * |b|) <= cos(theta)
    return step(dot(Face1Normal, Face2Normal) / length(Face2Normal), AngleThreshold);

}


#define CLIPLEFT(p) -p.w
#define CLIPRIGHT(p) p.w
#define CLIPTOP(p) p.w
#define CLIPBOTTOM(p) -p.w
#if NEGATIVE_CLIP_Z_VALUE
#define CLIPFAR(p) p.w  //ReverseZ do not matter
#define CLIPNEAR(p) -p.w
#else
#define CLIPFAR(p) p.w  //ReverseZ do not matter
#define CLIPNEAR(p) 0.0f
#endif

inline bool InX(float4 P) { return P.x >= CLIPLEFT(P) && P.x <= CLIPRIGHT(P); }
inline bool InY(float4 P) { return P.y >= CLIPBOTTOM(P) && P.y <= CLIPTOP(P); }
inline bool InZ(float4 P) { return P.z >= CLIPNEAR(P) && P.z <= CLIPFAR(P); }

int IsIn(float4 ClipPoint1, float4 ClipPoint2)
{
    bool P1X = InX(ClipPoint1);
    bool P1Y = InY(ClipPoint1);
    bool P1Z = InZ(ClipPoint1);
    bool P1In = P1X && P1Y && P1Z;

    bool P2X = InX(ClipPoint2);
    bool P2Y = InY(ClipPoint2);
    bool P2Z = InZ(ClipPoint2);
    bool P2In = P2X && P2Y && P2Z;

    int State = P1In && P2In ? 0 : -1;
    State = P1In && !P2In ? 1 : State;
    State = !P1In && P2In ? 2 : State;

    return State;
}

float IntersectWithXPlane(float ClipPlaneP1, float ClipPlaneP2, float4 P1, float4 P2, uint InterectVecIndex, inout uint InterectVec)
{
    float KFactor = P2.x - P1.x - ClipPlaneP2 + ClipPlaneP1;
    float T = (KFactor == 0.0f) ? -1.0f : ((ClipPlaneP1 - P1.x) / KFactor);
    uint Intersect = 0;
    if (T >= 0.0f && T <= 1.0f)
    {
        float4 IntersectP = P1 + T * (P2 - P1);
        Intersect = (InY(IntersectP) && InZ(IntersectP)) ? 1 : 0;
    }
    InterectVec = InterectVec | (Intersect << InterectVecIndex);

    return T;
}

float IntersectWithYPlane(float ClipPlaneP1, float ClipPlaneP2, float4 P1, float4 P2, uint InterectVecIndex, inout uint InterectVec)
{
    float KFactor = P2.y - P1.y - ClipPlaneP2 + ClipPlaneP1;
    float T = (KFactor == 0.0f) ? -1.0f : ((ClipPlaneP1 - P1.y) / KFactor);
    uint Intersect = 0;
    if (T >= 0.0f && T <= 1.0f)
    {
        float4 IntersectP = P1 + T * (P2 - P1);
        Intersect = (InX(IntersectP) && InZ(IntersectP)) ? 1 : 0;
    }
    InterectVec = InterectVec | (Intersect << InterectVecIndex);

    return T;
}

float IntersectWithZPlane(float ClipPlaneP1, float ClipPlaneP2, float4 P1, float4 P2, uint InterectVecIndex, inout uint InterectVec)
{
    float KFactor = P2.z - P1.z - ClipPlaneP2 + ClipPlaneP1;
    float T = (KFactor == 0.0f) ? -1.0f : ((ClipPlaneP1 - P1.z) / KFactor);
    uint Intersect = 0;
    if (T >= 0.0f && T <= 1.0f)
    {
        float4 IntersectP = P1 + T * (P2 - P1);
        Intersect = (InX(IntersectP) && InY(IntersectP)) ? 1 : 0;
    }
    InterectVec = InterectVec | (Intersect << InterectVecIndex);

    return T;
}

float3 PreClipping(float4 ClipPosition1, float4 ClipPosition2)
{
    float4 ClipPos1 = ClipPosition1;
    float4 ClipPos2 = ClipPosition2;

    if (ClipPos1.w == 0.0f || ClipPos2.w == 0.0f)
        return float3(-1.0f, 0.0f, 0.0f);

    float3 Result = float3(1.0f, 0.0f, 1.0f);
    int State = IsIn(ClipPos1, ClipPos2);
    if (State != 0)
    {
        float IntersectT[6] = { 0.0f, 0.0f, 0.0f, 0.0f,  0.0f, 0.0f };
        uint InterectVec = 0;
        IntersectT[0] = IntersectWithXPlane(CLIPLEFT(ClipPos1), CLIPLEFT(ClipPos2), ClipPos1, ClipPos2, 0, InterectVec);
        IntersectT[1] = IntersectWithXPlane(CLIPRIGHT(ClipPos1), CLIPRIGHT(ClipPos2), ClipPos1, ClipPos2, 1, InterectVec);
        IntersectT[2] = IntersectWithYPlane(CLIPTOP(ClipPos1), CLIPTOP(ClipPos2), ClipPos1, ClipPos2, 2, InterectVec);
        IntersectT[3] = IntersectWithYPlane(CLIPBOTTOM(ClipPos1), CLIPBOTTOM(ClipPos2), ClipPos1, ClipPos2, 3, InterectVec);
        IntersectT[4] = IntersectWithZPlane(CLIPNEAR(ClipPos1), CLIPNEAR(ClipPos2), ClipPos1, ClipPos2, 4, InterectVec);
        IntersectT[5] = IntersectWithZPlane(CLIPFAR(ClipPos1), CLIPFAR(ClipPos2), ClipPos1, ClipPos2, 5, InterectVec);

        uint IntersectIndex1 = firstbitlow(InterectVec);
        uint IntersectIndex2 = firstbithigh(InterectVec);
        if (State == 1)
        {
            Result.xz = IntersectIndex1 < 6 ? float2(1.0f, IntersectT[IntersectIndex1]) : float2(-1.0f, Result.z);
        }
        else if (State == 2)
        {
            Result.xy = IntersectIndex1 < 6 ? float2(1.0f, IntersectT[IntersectIndex1]) : float2(-1.0f, Result.y);
        }
        else
        {
            Result.xyz = (IntersectIndex1 < 6 && IntersectIndex2 < 6) ? float3(1.0f, IntersectT[IntersectIndex1], IntersectT[IntersectIndex2]) : float3(-1.0f, 0.0f, 0.0f);
            float T1 = Result.y;
            float T2 = Result.z;
            Result.y = min(T1, T2);
            Result.z = max(T1, T2);
        }
        
    }

    return Result;
}

inline float4 ClampPosition(float4 P)
{
    //return float4(min(CLIPRIGHT(P), max(CLIPLEFT(P), P.x)), min(CLIPTOP(P), max(CLIPBOTTOM(P), P.y)), min(CLIPFAR(P), max(CLIPNEAR(P), P.z)), P.w);
    return P;
}

float4 CalculateClipSpacePosition(float3 LocalPosition)
{
    float4 Transformed = mul(WorldViewProjection, float4(LocalPosition, 1.0));
    //Transformed.xyz = Transformed.xyz / Transformed.w;

    return Transformed;
}

float4 CalculateClipSpacePositionForClipping(float3 LocalPosition)
{
    float4 Transformed = mul(WorldViewProjectionForClipping, float4(LocalPosition, 1.0));

    return Transformed;
}

uint2 CalculatePixelLength(float2 UnifyNDCPosition1, float2 UnifyNDCPosition2)
{
    float2 PixelPos1 = float2(UnifyNDCPosition1.x * ScreenWidth, UnifyNDCPosition1.y * ScreenHeight);
    float2 PixelPos2 = float2(UnifyNDCPosition2.x * ScreenWidth, UnifyNDCPosition2.y * ScreenHeight);

    float PixelLength = ceil(length(PixelPos2 - PixelPos1));
    float ShrinkPixelLength = PixelLength > 2.0 ? (1.0 + floor(PixelLength * 0.5)) : PixelLength;

    return uint2((uint)PixelLength, (uint)(ShrinkPixelLength));
}


void ArgBufferCounting()
{
    int Original = 0;
    InterlockedAdd(ArgBuffer[0], 1, Original);
    if((uint)(Original + 1) % SLICE_PASS_PER_THREAD_ELEMENT_NUM == 0)
        InterlockedAdd(ArgBuffer[1], 1, Original);
}


/*
* 后续优化：
* 现在是一个thread检测3条边 -> 拆分成一个thread检测1条边
* 由于条件分支容易使得一个thread的代码拆分到多个warp执行(比如一个分支一次warp另外一个分支一次warp)
* 导致3条边同时检测下出现多个分支，这情况下可能效率还不如一次只检测1条边
* 
* 现在的三角形方式可能存在多条重复边：例如一个正方体只有18条边，但分成三角形检测后生成了21条边
* 1.先单独修改compute shader变成一次检测一条边，看性能是否有提升
* 2.如果有，就正式都修改成一次检测一条边的形式，C++的数据结构也改掉，就可以顺便解决掉重复边问题
*/
[numthreads(EXTRACT_PASS_PER_THREAD_ELEMENT_NUM, 1, 1)]
void Extraction (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= TotalAdjacencyTrianglesNum) return;

    AdjFace CurrentFace = AdjacencyTriangles[id.x];

    float3 VertexX = Vertices[CurrentFace.x];
    float3 VertexY = Vertices[CurrentFace.y];
    float3 VertexZ = Vertices[CurrentFace.z];

    bool AddXY = false;
    bool AddYZ = false;
    bool AddZX = false;

    bool XYIsBackFace = false;
    bool ZXIsBackFace = false;
    bool YZIsBackFace = false;

    float3 CurrentFaceNormal = ComputeNormal(VertexX, VertexY, VertexZ);

    bool NeedExtractSilhouette =  SilhouetteEnable > 0;
    float3 LocalViewVector = LocalSpaceViewPosition.xyz - (VertexX+VertexY+VertexZ)/3.0f;
    float SilhouettePremultiplyDotFactor = dot(CurrentFaceNormal, LocalViewVector);

    bool NeedExtractCrease = CreaseEnable > 0;
    float CreasePremultiplyAngleThreshold = length(CurrentFaceNormal) * (cos(CreaseAngleThreshold) + 0.000001f); //+1.0e-6 for Epsilon

    bool CurrentIsBackFace = SilhouettePremultiplyDotFactor < 0 ? true : false;


    if (CurrentFace.xy >= 1)
    {
        float3 AdjVertexXY = Vertices[CurrentFace.xy - 1];
        float3 AdjFaceXYNormal = ComputeNormal(VertexY, VertexX, AdjVertexXY);

        float DotFactor = dot(LocalViewVector, AdjFaceXYNormal);
        AddXY = AddXY || (NeedExtractSilhouette && IsSilhouette(SilhouettePremultiplyDotFactor, DotFactor));
        AddXY = AddXY || (NeedExtractCrease && IsCrease(CurrentFaceNormal, AdjFaceXYNormal, CreasePremultiplyAngleThreshold));

        XYIsBackFace = DotFactor < 0 ? true : false;
        bool XYBackFacing = CurrentIsBackFace && XYIsBackFace;

        float4 ClipPos1BeforeClip = CalculateClipSpacePosition(Vertices[CurrentFace.x]);
        float4 ClipPos2BeforeClip = CalculateClipSpacePosition(Vertices[CurrentFace.y]);
        float4 Pos1ForClipping = ClipPos1BeforeClip;
        float4 Pos2ForClipping = ClipPos2BeforeClip;
#if DEBUG_CLIPPING
        Pos1ForClipping = CalculateClipSpacePositionForClipping(Vertices[CurrentFace.x]);
        Pos2ForClipping = CalculateClipSpacePositionForClipping(Vertices[CurrentFace.y]);
#endif

        float3 ClipState = PreClipping(Pos1ForClipping, Pos2ForClipping);
        float4 ClipPos1 = ClampPosition(float4(ClipPos1BeforeClip + ClipState.y * (ClipPos2BeforeClip - ClipPos1BeforeClip)));
        float4 ClipPos2 = ClampPosition(float4(ClipPos1BeforeClip + ClipState.z * (ClipPos2BeforeClip - ClipPos1BeforeClip)));

        if (AddXY && ClipState.x >= 0.0f)
        {
            LineSegment Line;
            Line.ClipPosition[0] = ClipPos1;
            Line.ClipPosition[1] = ClipPos2;
            float4 NDCPos1 = CalculateNDCPosition(ClipPos1);
            float4 NDCPos2 = CalculateNDCPosition(ClipPos2);
            Line.NDCPosition[0] = UnifyNDCPosition(NDCPos1);
            Line.NDCPosition[1] = UnifyNDCPosition(NDCPos2);
            Line.BackFacing = XYBackFacing ? 1 : 0;
            uint2 PixelLength = CalculatePixelLength(Line.NDCPosition[0].xy, Line.NDCPosition[1].xy);
            Line.PixelLength = PixelLength.x;
            Line.PixelLengthShrink = PixelLength.y;
            Line.PixelLengthShrinkTotal = 0;
            Segments.Append(Line);
            ArgBufferCounting();
        }

        
    }

    if (CurrentFace.zx >= 1)
    {
        float3 AdjVertexZX = Vertices[CurrentFace.zx - 1];
        float3 AdjFaceZXNormal = ComputeNormal(VertexZ, AdjVertexZX, VertexX);

        float DotFactor = dot(LocalViewVector, AdjFaceZXNormal);
        AddZX = AddZX || (NeedExtractSilhouette && IsSilhouette(SilhouettePremultiplyDotFactor, DotFactor));
        AddZX = AddZX || (NeedExtractCrease && IsCrease(CurrentFaceNormal, AdjFaceZXNormal, CreasePremultiplyAngleThreshold));

        ZXIsBackFace = DotFactor < 0 ? true : false;
        bool ZXBackFacing = CurrentIsBackFace && ZXIsBackFace;

        float4 ClipPos1BeforeClip = CalculateClipSpacePosition(Vertices[CurrentFace.z]);
        float4 ClipPos2BeforeClip = CalculateClipSpacePosition(Vertices[CurrentFace.x]);
        float4 Pos1ForClipping = ClipPos1BeforeClip;
        float4 Pos2ForClipping = ClipPos2BeforeClip;
#if DEBUG_CLIPPING
        Pos1ForClipping = CalculateClipSpacePositionForClipping(Vertices[CurrentFace.z]);
        Pos2ForClipping = CalculateClipSpacePositionForClipping(Vertices[CurrentFace.x]);
#endif

        float3 ClipState = PreClipping(Pos1ForClipping, Pos2ForClipping);
        float4 ClipPos1 = ClampPosition(float4(ClipPos1BeforeClip + ClipState.y * (ClipPos2BeforeClip - ClipPos1BeforeClip)));
        float4 ClipPos2 = ClampPosition(float4(ClipPos1BeforeClip + ClipState.z * (ClipPos2BeforeClip - ClipPos1BeforeClip)));

        if (AddZX && ClipState.x >= 0.0f)
        {
            LineSegment Line;
            Line.ClipPosition[0] = ClipPos1;
            Line.ClipPosition[1] = ClipPos2;
            float4 NDCPos1 = CalculateNDCPosition(ClipPos1);
            float4 NDCPos2 = CalculateNDCPosition(ClipPos2);
            Line.NDCPosition[0] = UnifyNDCPosition(NDCPos1);
            Line.NDCPosition[1] = UnifyNDCPosition(NDCPos2);
            Line.BackFacing = ZXBackFacing ? 1 : 0;
            uint2 PixelLength = CalculatePixelLength(Line.NDCPosition[0].xy, Line.NDCPosition[1].xy);
            Line.PixelLength = PixelLength.x;
            Line.PixelLengthShrink = PixelLength.y;
            Line.PixelLengthShrinkTotal = 0;
            Segments.Append(Line);
            ArgBufferCounting();
        }

    }

    if (CurrentFace.yz >= 1)
    {
        float3 AdjVertexYZ = Vertices[CurrentFace.yz - 1];
        float3 AdjFaceYZNormal = ComputeNormal(AdjVertexYZ, VertexZ, VertexY);

        float DotFactor = dot(LocalViewVector, AdjFaceYZNormal);
        AddYZ = AddYZ || (NeedExtractSilhouette && IsSilhouette(SilhouettePremultiplyDotFactor, DotFactor));
        AddYZ = AddYZ || (NeedExtractCrease && IsCrease(CurrentFaceNormal, AdjFaceYZNormal, CreasePremultiplyAngleThreshold));

        YZIsBackFace = DotFactor < 0 ? true : false;
        bool YZBackFacing = CurrentIsBackFace && YZIsBackFace;

        float4 ClipPos1BeforeClip = CalculateClipSpacePosition(Vertices[CurrentFace.y]);
        float4 ClipPos2BeforeClip = CalculateClipSpacePosition(Vertices[CurrentFace.z]);
        float4 Pos1ForClipping = ClipPos1BeforeClip;
        float4 Pos2ForClipping = ClipPos2BeforeClip;
#if DEBUG_CLIPPING
        Pos1ForClipping = CalculateClipSpacePositionForClipping(Vertices[CurrentFace.y]);
        Pos2ForClipping = CalculateClipSpacePositionForClipping(Vertices[CurrentFace.z]);
#endif

        float3 ClipState = PreClipping(Pos1ForClipping, Pos2ForClipping); 
        float4 ClipPos1 = ClampPosition(float4(ClipPos1BeforeClip + ClipState.y * (ClipPos2BeforeClip - ClipPos1BeforeClip)));
        float4 ClipPos2 = ClampPosition(float4(ClipPos1BeforeClip + ClipState.z * (ClipPos2BeforeClip - ClipPos1BeforeClip)));

        if (AddYZ && ClipState.x >= 0.0f)
        {
            LineSegment Line;
            Line.ClipPosition[0] = ClipPos1;
            Line.ClipPosition[1] = ClipPos2;
            float4 NDCPos1 = CalculateNDCPosition(ClipPos1);
            float4 NDCPos2 = CalculateNDCPosition(ClipPos2);
            Line.NDCPosition[0] = UnifyNDCPosition(NDCPos1);
            Line.NDCPosition[1] = UnifyNDCPosition(NDCPos2);
            Line.BackFacing = YZBackFacing ? 1 : 0;
            uint2 PixelLength = CalculatePixelLength(Line.NDCPosition[0].xy, Line.NDCPosition[1].xy);
            Line.PixelLength = PixelLength.x;
            Line.PixelLengthShrink = PixelLength.y;
            Line.PixelLengthShrinkTotal = 0;
            Segments.Append(Line);
            ArgBufferCounting();
        }

    }


}
