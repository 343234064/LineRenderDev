// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Extraction

#include "Common.cginc"



StructuredBuffer<AdjVertex> Vertices;
StructuredBuffer<AdjFace> AdjacencyTriangles;

RWStructuredBuffer<uint> SegmentArgBuffer;
RWStructuredBuffer<LineSegment> Segments;
AppendStructuredBuffer<VisibleLineSegment> VisibleSegments;
RWStructuredBuffer<RunTimeVertexState> RunTimeVertexBuffer;

uniform float3 LocalSpaceViewPosition;
uniform float CreaseAngleThreshold;
uniform float4x4 WorldViewProjection;
uniform float4x4 WorldViewProjectionForClipping;
uniform float4  ScreenScaledResolution;



#define DEBUG_CLIPPING 0


float3 ComputeNormal(float3 p1, float3 p2, float3 p3)
{
    float3 U = p2 - p1;
    float3 V = p3 - p1;

    float3 Normal = float3(0.0f, 0.0f, 0.0f);
    /*
    Normal.x = U.y * V.z - U.z * V.y;
    Normal.y = U.z * V.x - U.x * V.z;
    Normal.z = U.x * V.y - U.y * V.x;
    */
    Normal = cross(U, V);
    // No need to normalize
    Normal = normalize(Normal);

    return Normal;
}


#define BACK_FACE_THRESHOLD 0.000000001
inline bool IsSilhouette(float DotFactor1, float DotFactor2)
{
    return step(DotFactor1 * DotFactor2, BACK_FACE_THRESHOLD);
}

inline bool IsCrease(float3 Face1Normal, float3 Face2Normal, float AngleThreshold)
{
    /// a dot b / (|a| * |b|) <= cos(theta)
    return step(dot(Face1Normal, Face2Normal) / length(Face2Normal), AngleThreshold);

}


#define CLIPLEFT(p) -p.w
#define CLIPRIGHT(p) p.w
#define CLIPTOP(p) p.w
#define CLIPBOTTOM(p) -p.w
#if NEGATIVE_CLIP_Z_VALUE
#define CLIPFAR(p) p.w  //ReverseZ do not matter
#define CLIPNEAR(p) -p.w
#else
#define CLIPFAR(p) p.w  //ReverseZ do not matter
#define CLIPNEAR(p) 0.0f
#endif

inline bool InX(float4 P) { return P.x >= CLIPLEFT(P) && P.x <= CLIPRIGHT(P); }
inline bool InY(float4 P) { return P.y >= CLIPBOTTOM(P) && P.y <= CLIPTOP(P); }
inline bool InZ(float4 P) { return P.z >= CLIPNEAR(P) && P.z <= CLIPFAR(P); }

int IsIn(float4 ClipPoint1, float4 ClipPoint2)
{
    bool P1X = InX(ClipPoint1);
    bool P1Y = InY(ClipPoint1);
    bool P1Z = InZ(ClipPoint1);
    bool P1In = P1X && P1Y && P1Z;

    bool P2X = InX(ClipPoint2);
    bool P2Y = InY(ClipPoint2);
    bool P2Z = InZ(ClipPoint2);
    bool P2In = P2X && P2Y && P2Z;

    int State = P1In && P2In ? 0 : -1;
    State = P1In && !P2In ? 1 : State;
    State = !P1In && P2In ? 2 : State;

    return State;
}

float IntersectWithXPlane(float ClipPlaneP1, float ClipPlaneP2, float4 P1, float4 P2, uint InterectVecIndex, inout uint InterectVec)
{
    float KFactor = P2.x - P1.x - ClipPlaneP2 + ClipPlaneP1;
    float T = (KFactor == 0.0f) ? -1.0f : ((ClipPlaneP1 - P1.x) / KFactor);
    uint Intersect = 0;
    if (T >= 0.0f && T <= 1.0f)
    {
        float4 IntersectP = P1 + T * (P2 - P1);
        Intersect = (InY(IntersectP) && InZ(IntersectP)) ? 1 : 0;
    }
    InterectVec = InterectVec | (Intersect << InterectVecIndex);

    return T;
}

float IntersectWithYPlane(float ClipPlaneP1, float ClipPlaneP2, float4 P1, float4 P2, uint InterectVecIndex, inout uint InterectVec)
{
    float KFactor = P2.y - P1.y - ClipPlaneP2 + ClipPlaneP1;
    float T = (KFactor == 0.0f) ? -1.0f : ((ClipPlaneP1 - P1.y) / KFactor);
    uint Intersect = 0;
    if (T >= 0.0f && T <= 1.0f)
    {
        float4 IntersectP = P1 + T * (P2 - P1);
        Intersect = (InX(IntersectP) && InZ(IntersectP)) ? 1 : 0;
    }
    InterectVec = InterectVec | (Intersect << InterectVecIndex);

    return T;
}

float IntersectWithZPlane(float ClipPlaneP1, float ClipPlaneP2, float4 P1, float4 P2, uint InterectVecIndex, inout uint InterectVec)
{
    float KFactor = P2.z - P1.z - ClipPlaneP2 + ClipPlaneP1;
    float T = (KFactor == 0.0f) ? -1.0f : ((ClipPlaneP1 - P1.z) / KFactor);
    uint Intersect = 0;
    if (T >= 0.0f && T <= 1.0f)
    {
        float4 IntersectP = P1 + T * (P2 - P1);
        Intersect = (InX(IntersectP) && InY(IntersectP)) ? 1 : 0;
    }
    InterectVec = InterectVec | (Intersect << InterectVecIndex);

    return T;
}

float3 PreClipping(float4 ClipPosition1, float4 ClipPosition2)
{
    float4 ClipPos1 = ClipPosition1;
    float4 ClipPos2 = ClipPosition2;

    if (ClipPos1.w == 0.0f || ClipPos2.w == 0.0f)
        return float3(-1.0f, 0.0f, 0.0f);

    float3 Result = float3(1.0f, 0.0f, 1.0f);
    int State = IsIn(ClipPos1, ClipPos2);
    if (State != 0)
    {
        float IntersectT[6] = { 0.0f, 0.0f, 0.0f, 0.0f,  0.0f, 0.0f };
        uint InterectVec = 0;
        IntersectT[0] = IntersectWithXPlane(CLIPLEFT(ClipPos1), CLIPLEFT(ClipPos2), ClipPos1, ClipPos2, 0, InterectVec);
        IntersectT[1] = IntersectWithXPlane(CLIPRIGHT(ClipPos1), CLIPRIGHT(ClipPos2), ClipPos1, ClipPos2, 1, InterectVec);
        IntersectT[2] = IntersectWithYPlane(CLIPTOP(ClipPos1), CLIPTOP(ClipPos2), ClipPos1, ClipPos2, 2, InterectVec);
        IntersectT[3] = IntersectWithYPlane(CLIPBOTTOM(ClipPos1), CLIPBOTTOM(ClipPos2), ClipPos1, ClipPos2, 3, InterectVec);
        IntersectT[4] = IntersectWithZPlane(CLIPNEAR(ClipPos1), CLIPNEAR(ClipPos2), ClipPos1, ClipPos2, 4, InterectVec);
        IntersectT[5] = IntersectWithZPlane(CLIPFAR(ClipPos1), CLIPFAR(ClipPos2), ClipPos1, ClipPos2, 5, InterectVec);

        uint IntersectIndex1 = firstbitlow(InterectVec);
        uint IntersectIndex2 = firstbithigh(InterectVec);
        if (State == 1)
        {
            Result.xz = IntersectIndex1 < 6 ? float2(1.0f, IntersectT[IntersectIndex1]) : float2(-1.0f, Result.z);
        }
        else if (State == 2)
        {
            Result.xy = IntersectIndex1 < 6 ? float2(1.0f, IntersectT[IntersectIndex1]) : float2(-1.0f, Result.y);
        }
        else
        {
            Result.xyz = (IntersectIndex1 < 6 && IntersectIndex2 < 6) ? float3(1.0f, IntersectT[IntersectIndex1], IntersectT[IntersectIndex2]) : float3(-1.0f, 0.0f, 0.0f);
            float T1 = Result.y;
            float T2 = Result.z;
            Result.y = min(T1, T2);
            Result.z = max(T1, T2);
        }
        
    }

    return Result;
}

inline float4 ClampPosition(float4 P)
{
    //return float4(min(CLIPRIGHT(P), max(CLIPLEFT(P), P.x)), min(CLIPTOP(P), max(CLIPBOTTOM(P), P.y)), min(CLIPFAR(P), max(CLIPNEAR(P), P.z)), P.w);
    return P;
}

float4 CalculateClipSpacePosition(float3 LocalPosition)
{
    float4 Transformed = mul(WorldViewProjection, float4(LocalPosition, 1.0));
    //Transformed.xyz = Transformed.xyz / Transformed.w;

    return Transformed;
}

float4 CalculateClipSpacePositionForClipping(float3 LocalPosition)
{
    float4 Transformed = mul(WorldViewProjectionForClipping, float4(LocalPosition, 1.0));

    return Transformed;
}

uint2 CalculatePixelLength(float2 UnifyNDCPosition1, float2 UnifyNDCPosition2)
{
    float ScreenWidth = ScreenScaledResolution.x;
    float ScreenHeight = ScreenScaledResolution.y;

    float2 PixelPos1 = float2(UnifyNDCPosition1.x * ScreenWidth, UnifyNDCPosition1.y * ScreenHeight);
    float2 PixelPos2 = float2(UnifyNDCPosition2.x * ScreenWidth, UnifyNDCPosition2.y * ScreenHeight);

    float PixelLength = ceil(length(PixelPos2 - PixelPos1));
    float ShrinkPixelLength = PixelLength > 2.0 ? (1.0 + floor(PixelLength * 0.5)) : PixelLength;

    return uint2((uint)PixelLength, (uint)(ShrinkPixelLength));
}


int ArgBufferCounting(bool Visible)
{
    int Original = 0;
    InterlockedAdd(SegmentArgBuffer[0], Visible ? 1 : 0, Original);

    if((uint)(Original + 1) % SLICE_PASS_PER_THREAD_ELEMENT_NUM == 0)
        InterlockedAdd(SegmentArgBuffer[1], Visible ? 1 : 0, Original);

    InterlockedAdd(SegmentArgBuffer[4], 1, Original);
    int Id = Original;
    return Id;
}




uint4 CheckVertexIndex(uint2 VertexIndex, float3 ClipState)
{
    return uint4(VertexIndex, ClipState.y <= 0.0000001f ? 0 : 1, ClipState.z >= 0.9999999f ? 0 : 1);
}



void SyncAdjacency(uint VertexIndex, int LineId)
{
    // Sync adjacency for chainning pass
    uint RunTimeIndex = VertexIndex;

    // Add adj num
    uint Original = 0;
    InterlockedAdd(RunTimeVertexBuffer[RunTimeIndex].AdjNum, 1, Original);

    if (Original <= 2) {
        Original = -1;
        InterlockedCompareExchange(RunTimeVertexBuffer[RunTimeIndex].Left, -1, LineId, Original);
        if (Original != -1)
            InterlockedCompareExchange(RunTimeVertexBuffer[RunTimeIndex].Right, -1, LineId, Original);
    }

}


void ExtractEdge(float3 V0, float3 V1, uint2 Index, 
    uint2 MeshletIndex, 
    float3 CurrentFaceNormal, float3 AdjFaceNormal, float3 LocalViewVector, float CreasePremultiplyAngleThreshold)
{
    bool Add = false;

    bool NeedExtractSilhouette = SilhouetteEnable > 0;
    bool NeedExtractCrease = CreaseEnable > 0;

    float DotFactorCurrentFace = dot(CurrentFaceNormal, LocalViewVector);
    float DotFactorAdjFace = dot(AdjFaceNormal, LocalViewVector);

    Add = Add || (NeedExtractSilhouette && IsSilhouette(DotFactorCurrentFace, DotFactorAdjFace));
    Add = Add || (NeedExtractCrease && IsCrease(CurrentFaceNormal, AdjFaceNormal, CreasePremultiplyAngleThreshold));

    bool CurrentIsBackFace = step(DotFactorCurrentFace, BACK_FACE_THRESHOLD);
    bool AdjIsBackFace = step(DotFactorAdjFace, BACK_FACE_THRESHOLD);
    bool BackFacing = CurrentIsBackFace && AdjIsBackFace;

    float4 ClipPos0BeforeClip = CalculateClipSpacePosition(V0);
    float4 ClipPos1BeforeClip = CalculateClipSpacePosition(V1);
    float4 Pos0ForClipping = ClipPos0BeforeClip;
    float4 Pos1ForClipping = ClipPos1BeforeClip;
#if DEBUG_CLIPPING
    Pos0ForClipping = CalculateClipSpacePositionForClipping(V0);
    Pos1ForClipping = CalculateClipSpacePositionForClipping(V1);
#endif

    float3 ClipState = PreClipping(Pos0ForClipping, Pos1ForClipping);
    float4 ClipPos0 = ClampPosition(float4(ClipPos0BeforeClip + ClipState.y * (ClipPos1BeforeClip - ClipPos0BeforeClip)));
    float4 ClipPos1 = ClampPosition(float4(ClipPos0BeforeClip + ClipState.z * (ClipPos1BeforeClip - ClipPos0BeforeClip)));

    bool UnClipped = ClipState.x >= 0.0f;
    if (Add)
    {
        float4 NDCPos0 = CalculateNDCPosition(ClipPos0);
        float4 NDCPos1 = CalculateNDCPosition(ClipPos1);
        NDCPos0 = UnifyNDCPosition(NDCPos0);
        NDCPos1 = UnifyNDCPosition(NDCPos1);

        LineSegment Line = (LineSegment)0;

        Line.NDCPosition[0] = float4(NDCPos0.xy, ClipPos0.zw);
        Line.NDCPosition[1] = float4(NDCPos1.xy, ClipPos1.zw);

        Line.BackFacing = BackFacing ? 1 : 0;

        //uint4 VertexIndex = CheckVertexIndex(uint2(V1, V2), ClipState);
        Line.RunTimeVertexIndex[0] = Index.x;
        Line.RunTimeVertexIndex[1] = Index.y;

        Line.Direction = normalize(NDCPos1.xy - NDCPos0.xy);

        Line.MeshletIndex[0] = MeshletIndex.x;
        Line.MeshletIndex[1] = MeshletIndex.y;

        Line.Id = ArgBufferCounting(UnClipped);
        Segments[Line.Id] = Line;

        if (UnClipped) {

            VisibleLineSegment VisibleLine = (VisibleLineSegment)0;
            uint2 PixelLength = CalculatePixelLength(Line.NDCPosition[0].xy, Line.NDCPosition[1].xy);
            VisibleLine.PixelLength = PixelLength.x;
            VisibleLine.PixelLengthShrink = PixelLength.y;
            VisibleLine.PixelLengthShrinkTotal = 0;

            float2 NDC0XYBeforeClip = UnifyNDCPositionXY(CalculateNDCPositionXY(ClipPos0BeforeClip));
            float2 NDC1XYBeforeClip = UnifyNDCPositionXY(CalculateNDCPositionXY(ClipPos1BeforeClip));
            VisibleLine.InvPixelLengthBeforeClippedMinusOne = 1.0f / float(CalculatePixelLength(NDC0XYBeforeClip, NDC1XYBeforeClip).x - 1.0f);
            VisibleLine.ClippedPositionOffset = CalculatePixelLength(NDC0XYBeforeClip, Line.NDCPosition[0].xy).x;
            VisibleLine.Id = Line.Id;
            VisibleSegments.Append(VisibleLine);

        }

        SyncAdjacency(Index.x, Line.Id);
        SyncAdjacency(Index.y, Line.Id);
    }

}


[numthreads(EXTRACT_PASS_PER_THREAD_ELEMENT_NUM, 1, 1)]
void Extraction (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= TotalAdjacencyTrianglesNum) return;

    AdjFace CurrentFace = AdjacencyTriangles[id.x];


    float3 VertexX = Vertices[CurrentFace.x].v;
    float3 VertexY = Vertices[CurrentFace.y].v;
    float3 VertexZ = Vertices[CurrentFace.z].v;

    bool AddXY = false;
    bool AddYZ = false;
    bool AddZX = false;

    float3 CurrentFaceNormal = ComputeNormal(VertexX, VertexY, VertexZ);
    float CreasePremultiplyAngleThreshold = length(CurrentFaceNormal) * (cos(CreaseAngleThreshold) + 0.000001f); //+1.0e-6 for Epsilon

    if (CurrentFace.xy >= 1)
    {
        float3 AdjVertexXY = Vertices[CurrentFace.xy - 1].v;
        float3 AdjFaceXYNormal = ComputeNormal(VertexY, VertexX, AdjVertexXY);
        float3 LocalViewVector = normalize(LocalSpaceViewPosition.xyz - (VertexX + VertexY) * 0.5f);

        ExtractEdge(VertexX, VertexY, uint2(CurrentFace.x, CurrentFace.y), 
            uint2(CurrentFace.xyLayer1, CurrentFace.xyLayer2), 
            CurrentFaceNormal, AdjFaceXYNormal, LocalViewVector, CreasePremultiplyAngleThreshold);
    }

    if (CurrentFace.zx >= 1)
    {
        float3 AdjVertexZX = Vertices[CurrentFace.zx - 1].v;
        float3 AdjFaceZXNormal = ComputeNormal(VertexZ, AdjVertexZX, VertexX);
        float3 LocalViewVector = normalize(LocalSpaceViewPosition.xyz - (VertexX + VertexZ) * 0.5f);

        ExtractEdge(VertexZ, VertexX, uint2(CurrentFace.z, CurrentFace.x),
            uint2(CurrentFace.zxLayer1, CurrentFace.zxLayer2), 
            CurrentFaceNormal, AdjFaceZXNormal, LocalViewVector, CreasePremultiplyAngleThreshold);
    }

    if (CurrentFace.yz >= 1)
    {
        float3 AdjVertexYZ = Vertices[CurrentFace.yz - 1].v;
        float3 AdjFaceYZNormal = ComputeNormal(AdjVertexYZ, VertexZ, VertexY);
        float3 LocalViewVector = normalize(LocalSpaceViewPosition.xyz - (VertexY + VertexZ) * 0.5f);

        ExtractEdge(VertexY, VertexZ, uint2(CurrentFace.y, CurrentFace.z),
            uint2(CurrentFace.yzLayer1, CurrentFace.yzLayer2), 
            CurrentFaceNormal, AdjFaceYZNormal, LocalViewVector, CreasePremultiplyAngleThreshold);
    }


}
