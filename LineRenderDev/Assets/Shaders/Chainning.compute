// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Chainning


#include "Common.cginc"


StructuredBuffer<uint> RArgBuffer;
StructuredBuffer<uint> RArgBuffer2;
StructuredBuffer<LineHead> LineHeadBuffer;
RWStructuredBuffer<LineMesh> LineMeshBuffer;

#define LINEHEAD_SIZE RArgBuffer[CHAINNING_PASS_LINEHEAD_COUNT]


inline bool IsConnected(uint LinkId)
{
	return (LinkId != 0xffffffff);
}


#define MAX_LOOP_NUM 2048

[numthreads(CHAINNING_PASS_PER_THREAD_ELEMENT_NUM, 1, 1)]
void Chainning (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= LINEHEAD_SIZE) return;

	LineHead CurrentHead = LineHeadBuffer[id.x];

	uint LoopNum = 0;
	uint NextLink = CurrentHead.Data;

	
	const uint MeshletLayer = 0;
	
	uint LineMeshId = GET_LINEHEAD_INDEX(NextLink);
	uint StartDirection = GET_LINEHEAD_DIRECTION(NextLink);
	uint StartPoint = StartDirection;

	LineMesh FirstLineMesh = LineMeshBuffer[LineMeshId];
	uint PrevMeshletIndex = FirstLineMesh.MeshletData[0];
	uint GroupId = GET_ANCHOR_INDEX(FirstLineMesh.Anchor[0]) + GET_ANCHOR_INDEX(FirstLineMesh.Anchor[1]);

	do
	{
		LineMeshId = GET_LINEHEAD_INDEX(NextLink);
		StartPoint = 1 - GET_LINEHEAD_DIRECTION(NextLink);

		LineMesh CurrentLineMesh = LineMeshBuffer[LineMeshId];
		NextLink = CurrentLineMesh.LinkId[StartPoint];
		
		//if (PrevMeshletIndex != CurrentLineMesh.MeshletData[MeshletLayer])
		//	break;

		if(GET_ANCHOR_TYPE(CurrentLineMesh.Anchor[StartPoint]) == 1)
			LoopNum++;

		/////////////////////



		//LineMeshBuffer[LineMeshId].GroupId[1] = 1;

		

		////////////////////
		PrevMeshletIndex = CurrentLineMesh.MeshletData[MeshletLayer];

	} while (IsConnected(NextLink) && LoopNum < MAX_LOOP_NUM);


}
