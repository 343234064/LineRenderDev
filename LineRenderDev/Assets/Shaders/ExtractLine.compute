// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct AdjFace
{
    uint x;
    uint y;
    uint z;
    uint xy;
    uint yz;
    uint zx;
};


StructuredBuffer<float3> Vertices;
StructuredBuffer<AdjFace> AdjacencyTriangles;

AppendStructuredBuffer<uint2> LineIndices;

//#define CreaseAngleThreshold 0.0f
uniform float CreaseAngleThreshold;
uniform float SilhouetteAngleThreshold;

cbuffer Constants
{
    uint TotalAdjacencyTrianglesNum;
    uint SilhouetteEnable;
    uint CreaseEnable;
    uint BorderEnable;
};


float3 ComputeNormal(float3 p1, float3 p2, float3 p3)
{
    float3 U = p2 - p1;
    float3 V = p3 - p1;

    float3 Normal = float3(0.0f, 0.0f, 0.0f);
    Normal.x = U.y * V.z - U.z * V.y;
    Normal.y = U.z * V.x - U.x * V.z;
    Normal.z = U.x * V.y - U.y * V.x;

    return normalize(Normal);
}


[numthreads(256, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= TotalAdjacencyTrianglesNum) return;

    AdjFace CurrentFace = AdjacencyTriangles[id.x];
    uint2 xy = uint2(CurrentFace.x, CurrentFace.y);
    uint2 yz = uint2(CurrentFace.y, CurrentFace.z);
    uint2 zx = uint2(CurrentFace.z, CurrentFace.x);

    float3 vertex_x = Vertices[CurrentFace.x];
    float3 vertex_y = Vertices[CurrentFace.y];
    float3 vertex_z = Vertices[CurrentFace.z];

    float3 CurrentFaceNormal = ComputeNormal(vertex_x, vertex_y, vertex_z);
    
    if (CurrentFace.xy != 0)
    {
        float3 adj_vertex_xy = Vertices[CurrentFace.xy - 1];
        float3 AdjFaceXYNormal = ComputeNormal(vertex_y, vertex_x, adj_vertex_xy);
        float angle = dot(CurrentFaceNormal, AdjFaceXYNormal);
        if (angle <= CreaseAngleThreshold)
        {
            LineIndices.Append(xy);
        }
    }

    if (CurrentFace.zx != 0)
    {
        float3 adj_vertex_zx = Vertices[CurrentFace.zx - 1];
        float3 AdjFaceZXNormal = ComputeNormal(vertex_z, adj_vertex_zx, vertex_x);
        float angle = dot(CurrentFaceNormal, AdjFaceZXNormal);
        if (angle <= CreaseAngleThreshold)
        {
            LineIndices.Append(zx);
        }
    }

    if (CurrentFace.yz != 0)
    {
        float3 adj_vertex_yz = Vertices[CurrentFace.yz - 1];
        float3 AdjFaceYZNormal = ComputeNormal(adj_vertex_yz, vertex_z, vertex_y);
        float angle = dot(CurrentFaceNormal, AdjFaceYZNormal);
        if (angle <= CreaseAngleThreshold)
        {
            LineIndices.Append(yz);
        }
    }
    //LineIndices.Append(xy);
    //LineIndices.Append(yz);
    //LineIndices.Append(zx);


}
