// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct AdjFace
{
    uint x;
    uint y;
    uint z;
    uint xy;
    uint yz;
    uint zx;
};


StructuredBuffer<float3> Vertices;
StructuredBuffer<AdjFace> AdjacencyTriangles;

AppendStructuredBuffer<uint2> LineIndices;

uniform float CreaseAngleThreshold;
uniform float SilhouetteAngleThreshold;

cbuffer Constants
{
    uint TotalAdjacencyTrianglesNum;
    uint SilhouetteEnable;
    uint CreaseEnable;
    uint BorderEnable;
};


float3 ComputeNormal(float3 p1, float3 p2, float3 p3)
{
    float3 U = p2 - p1;
    float3 V = p3 - p1;

    float3 Normal = float3(0.0f, 0.0f, 0.0f);
    /*
    Normal.x = U.y * V.z - U.z * V.y;
    Normal.y = U.z * V.x - U.x * V.z;
    Normal.z = U.x * V.y - U.y * V.x;
    */
    Normal = cross(U, V);

    return normalize(Normal);
}

bool IsCrease(float3 face1Normal, float3 face2Normal)
{
    return step(pow(dot(face1Normal, face2Normal) / cos(CreaseAngleThreshold), 2), dot(face1Normal, face1Normal) * dot(face2Normal, face2Normal));
}


[numthreads(256, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= TotalAdjacencyTrianglesNum) return;

    AdjFace CurrentFace = AdjacencyTriangles[id.x];
    uint2 xy = uint2(CurrentFace.x, CurrentFace.y);
    uint2 yz = uint2(CurrentFace.y, CurrentFace.z);
    uint2 zx = uint2(CurrentFace.z, CurrentFace.x);

    float3 vertex_x = Vertices[CurrentFace.x];
    float3 vertex_y = Vertices[CurrentFace.y];
    float3 vertex_z = Vertices[CurrentFace.z];

    float3 CurrentFaceNormal = ComputeNormal(vertex_x, vertex_y, vertex_z);


    if (CurrentFace.xy >= 1)
    {
        float3 adj_vertex_xy = Vertices[CurrentFace.xy - 1];
        float3 AdjFaceXYNormal = ComputeNormal(vertex_y, vertex_x, adj_vertex_xy);

        float angle = dot(CurrentFaceNormal, AdjFaceXYNormal);
        //if (angle <= CreaseAngleThreshold)
        if(IsCrease(CurrentFaceNormal, AdjFaceXYNormal))
        {
            LineIndices.Append(xy);
        }
    }

    if (CurrentFace.zx >= 1)
    {
        float3 adj_vertex_zx = Vertices[CurrentFace.zx - 1];
        float3 AdjFaceZXNormal = ComputeNormal(vertex_x, vertex_z, adj_vertex_zx);

        float angle = dot(CurrentFaceNormal, AdjFaceZXNormal);
        //if (angle <= CreaseAngleThreshold)
        if (IsCrease(CurrentFaceNormal, AdjFaceZXNormal))
        {
            LineIndices.Append(zx);
        }
    }

    if (CurrentFace.yz >= 1)
    {
        float3 adj_vertex_yz = Vertices[CurrentFace.yz - 1];
        float3 AdjFaceYZNormal = ComputeNormal(vertex_z, vertex_y, adj_vertex_yz);

        float angle = dot(CurrentFaceNormal, AdjFaceYZNormal);
        //if (angle <= CreaseAngleThreshold)
        if (IsCrease(CurrentFaceNormal, AdjFaceYZNormal))
        {
            LineIndices.Append(yz);
        }
    }
    //LineIndices.Append(xy);
    //LineIndices.Append(yz);
    //LineIndices.Append(zx);


}
