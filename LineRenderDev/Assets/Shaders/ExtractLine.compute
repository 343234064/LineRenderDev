// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct AdjFace
{
    uint x;
    uint y;
    uint z;
    uint xy;
    uint yz;
    uint zx;
};


StructuredBuffer<float3> Vertices;
StructuredBuffer<AdjFace> AdjacencyTriangles;

AppendStructuredBuffer<uint2> LineIndices;

uniform float4 LocalSpaceViewPosition;
uniform float CreaseAngleThreshold;

cbuffer Constants
{
    uint TotalAdjacencyTrianglesNum;
    uint SilhouetteEnable;
    uint CreaseEnable;
    uint BorderEnable;
};


float3 ComputeNormal(float3 p1, float3 p2, float3 p3)
{
    float3 U = p2 - p1;
    float3 V = p3 - p1;

    float3 Normal = float3(0.0f, 0.0f, 0.0f);
    /*
    Normal.x = U.y * V.z - U.z * V.y;
    Normal.y = U.z * V.x - U.x * V.z;
    Normal.z = U.x * V.y - U.y * V.x;
    */
    Normal = cross(U, V);
    // No need to normalize
    // Normal = normalize(Normal);

    return Normal;
}

bool IsSilhouette(float3 ViewVector, float3 Face2Normal, float DotFactor)
{
    return (DotFactor * dot(Face2Normal, ViewVector)) <= 0;
}

bool IsCrease(float3 Face1Normal, float3 Face2Normal, float AngleThreshold)
{
    /// a dot b / (|a| * |b|) <= cos(theta)
    return step(dot(Face1Normal, Face2Normal) / length(Face2Normal), AngleThreshold);

}


[numthreads(256, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= TotalAdjacencyTrianglesNum) return;

    AdjFace CurrentFace = AdjacencyTriangles[id.x];
    uint2 XY = uint2(CurrentFace.x, CurrentFace.y);
    uint2 YZ = uint2(CurrentFace.y, CurrentFace.z);
    uint2 ZX = uint2(CurrentFace.z, CurrentFace.x);

    float3 VertexX = Vertices[CurrentFace.x];
    float3 VertexY = Vertices[CurrentFace.y];
    float3 VertexZ = Vertices[CurrentFace.z];

    float3 CurrentFaceNormal = ComputeNormal(VertexX, VertexY, VertexZ);

    bool AddXY = false;
    bool AddYZ = false;
    bool AddZX = false;

    bool NeedExtractSilhouette = step(1, SilhouetteEnable);
    float3 LocalViewVector = LocalSpaceViewPosition.xyz - (VertexX + VertexY + VertexZ) / 3.0f;
    float SilhouettePremultiplyDotFactor = dot(CurrentFaceNormal, LocalViewVector);

    bool NeedExtractCrease = step(1, CreaseEnable);
    float CreasePremultiplyAngleThreshold = length(CurrentFaceNormal) * (cos(CreaseAngleThreshold) + 0.000001f); //+1.0e-6 for Epsilon


    if (CurrentFace.xy >= 1)
    {
        float3 AdjVertexXY = Vertices[CurrentFace.xy - 1];
        float3 AdjFaceXYNormal = ComputeNormal(VertexY, VertexX, AdjVertexXY);

        AddXY = AddXY || (NeedExtractSilhouette && IsSilhouette(LocalViewVector, AdjFaceXYNormal, SilhouettePremultiplyDotFactor));
        AddXY = AddXY || (NeedExtractCrease && IsCrease(CurrentFaceNormal, AdjFaceXYNormal, CreasePremultiplyAngleThreshold));

        if(AddXY)
        {
            LineIndices.Append(XY);
        }
    }

    if (CurrentFace.zx >= 1)
    {
        float3 AdjVertexZX = Vertices[CurrentFace.zx - 1];
        float3 AdjFaceZXNormal = ComputeNormal(VertexZ, AdjVertexZX, VertexX);

        AddZX = AddZX || (NeedExtractSilhouette && IsSilhouette(LocalViewVector, AdjFaceZXNormal, SilhouettePremultiplyDotFactor));
        AddZX = AddZX || (NeedExtractCrease && IsCrease(CurrentFaceNormal, AdjFaceZXNormal, CreasePremultiplyAngleThreshold));

        if (AddZX)
        {
            LineIndices.Append(ZX);
        }
    }

    if (CurrentFace.yz >= 1)
    {
        float3 AdjVertexYZ = Vertices[CurrentFace.yz - 1];
        float3 AdjFaceYZNormal = ComputeNormal(AdjVertexYZ, VertexZ, VertexY);

        AddYZ = AddYZ || (NeedExtractSilhouette && IsSilhouette(LocalViewVector, AdjFaceYZNormal, SilhouettePremultiplyDotFactor));
        AddYZ = AddYZ || (NeedExtractCrease && IsCrease(CurrentFaceNormal, AdjFaceYZNormal, CreasePremultiplyAngleThreshold));

        if (AddYZ)
        {
            LineIndices.Append(YZ);
        }
    }

}
